---
layout: post
title: "From Neovim to Godot: A Developer’s Journey Through Curiosity and Code"
date: 2025-10-17
categories: "blog"
---

There’s something special about building things — watching code come to life in a way that feels both mechanical and creative. That feeling keeps me chasing new languages, frameworks, and paradigms. Every tool, every line of code, opens a new door.

## The Neovim Phase: Where It All Started

My journey really kicked into gear with Neovim. What started as a few configuration tweaks turned into something deeper — shaping the editor into an extension of my mind. Writing Lua to make my tools faster and more expressive taught me one of the most important lessons in programming:

Every layer of abstraction is an opportunity to learn what’s underneath.

Through Lua, I began noticing patterns that connect programming ecosystems — the way Neovim lazily loads modules, how Rust enforces borrowing and lifetimes, how Unity keeps things feeling smooth and intuitive. Each system had its own philosophy, but all were trying to balance flexibility with safety.

## Unity: Iteration and Interaction

My curiosity eventually spilled into game development, and Unity was the first major stop. Its clean editor, real-time feedback, and the comfort of C# made it the perfect playground.

At first, I followed tutorials — building prototypes, breaking them, rebuilding them again. But each project became its own little detour:

Building first-person controllers taught me about input systems and frame timing.

Experimenting with animation trees showed me how to structure motion logic.

Writing basic shaders introduced me to how the GPU sees the world.

That iterative, visual feedback loop was addictive. It shifted how I thought about programming — from something abstract to something you can feel.

## Godot: Systems Thinking and Design Flow

Then came Godot, and it felt like stepping backstage. Suddenly, I could see the entire engine working — scripts, nodes, signals, and rendering all woven together in an open-source ecosystem.

With Godot, my detours became more experimental:

Building state machines for character logic taught me to think in terms of flow and transitions.

Simulating boids led me into emergent behavior and data structures.

Playing with procedural generation made me appreciate controlled randomness.

Designing UI systems showed me how user experience and performance interact.

Each system connected to the others. It wasn’t just coding anymore — it was designing behavior. Godot taught me how structure and creativity could exist side by side.

## Rust: Under the Hood

The deeper I went, the more I wanted to understand what was really happening under the surface. That’s when I found Rust.

Rust is a different kind of teacher. It forces you to slow down and think about ownership, lifetimes, and safety. My detours here were smaller but sharper:

Understanding low-level memory management and why safety matters.

Experimenting with batching and rendering performance in Godot-Rust.

Rewriting small tools — like my atomic notes parser — to learn how Rust models data flow.

Rust made me see data as something living — moving, being borrowed, returned, and owned. It changed how I think about structure at every level.

## Learning by Detour

Looking back, none of this was planned. Every project led somewhere unexpected:

Unity taught me iteration and interaction.

Godot taught me systems and design.

Rust taught me structure and safety.

Each one fed into the next. Together, they shaped how I see programming — not as a straight path, but as a network of discoveries.

## Build to Learn

If there’s one philosophy behind all this, it’s simple: build to learn.
Reading is good. Breaking things is better.

Every project is a mirror for your understanding, and every bug is an invitation to look closer. For me, programming isn’t just about solving problems — it’s about exploring connections, one abstraction and one detour at a time.
